# ¬© CodeXBots (Rahul)
import os, requests
import logging
import random
import asyncio
import string
import pytz
from datetime import datetime
from Script import script
from pyrogram import Client, filters, enums
from pyrogram.errors import ChatAdminRequired, FloodWait
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from database.ia_filterdb import Media, get_file_details, get_bad_files, unpack_new_file_id
from database.users_chats_db import db
from info import ADMINS, THREE_VERIFY_GAP, LOG_CHANNEL, USERNAME, VERIFY_IMG, IS_VERIFY, FILE_CAPTION, AUTH_CHANNEL, SHORTENER_WEBSITE, SHORTENER_API, SHORTENER_WEBSITE2, SHORTENER_API2, SHORTENER_API3, SHORTENER_WEBSITE3, LOG_API_CHANNEL, TWO_VERIFY_GAP, TUTORIAL, TUTORIAL2, TUTORIAL3, QR_CODE, DELETE_TIME
from utils import get_settings, save_group_settings, is_subscribed, get_size, get_shortlink, is_check_admin, get_status, temp, get_readable_time
import re
import json
import base64

@Client.on_message(filters.command("start") & filters.incoming)
async def start(client:Client, message): 
    m = message
    user_id = m.from_user.id
    if len(m.command) == 2 and m.command[1].startswith('notcopy'):
        _, userid, verify_id, file_id = m.command[1].split("_", 3)
        user_id = int(userid)
        grp_id = temp.CHAT.get(user_id, 0)
        settings = await get_settings(grp_id)         
        verify_id_info = await db.get_verify_id_info(user_id, verify_id)
        if not verify_id_info or verify_id_info["verified"]:
            await message.reply("<b> ü…™…¥·¥ã ·¥áx·¥ò…™ Ä·¥á·¥Ö ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥...</b>")
            return  
        ist_timezone = pytz.timezone('Asia/Kolkata')
        if await db.user_verified(user_id):
            key = "third_time_verified"
        else:
            key = "second_time_verified" if await db.is_user_verified(user_id) else "last_verified"
        current_time = datetime.now(tz=ist_timezone)
        result = await db.update_notcopy_user(user_id, {key:current_time})
        await db.update_verify_id_info(user_id, verify_id, {"verified":True})
        if key == "third_time_verified": 
            num = 3 
        else: 
            num =  2 if key == "second_time_verified" else 1 
        if key == "third_time_verified": 
            msg = script.THIRDT_VERIFY_COMPLETE_TEXT
        else:
            msg = script.SECOND_VERIFY_COMPLETE_TEXT if key == "second_time_verified" else script.VERIFY_COMPLETE_TEXT
        await client.send_message(settings['log'], script.VERIFIED_LOG_TEXT.format(m.from_user.mention, user_id, datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%d %B %Y'), num))
        btn = [[
            InlineKeyboardButton("‚úÖ ·¥Ñ ü…™·¥Ñ·¥ã  ú·¥á Ä·¥á ·¥õ·¥è …¢·¥á·¥õ Íú∞…™ ü·¥á ‚úÖ", url=f"https://telegram.me/{temp.U_NAME}?start=file_{grp_id}_{file_id}"),
        ]]
        reply_markup=InlineKeyboardMarkup(btn)
        await m.reply_photo(
            photo=(VERIFY_IMG),
            caption=msg.format(message.from_user.mention),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        return 
    if message.chat.type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        status = get_status()
        aks=await message.reply_text(f"<b>üî•  è·¥ás {status},\n ú·¥è·¥° ·¥Ñ·¥Ä…¥ …™  ú·¥á ü·¥ò  è·¥è·¥ú??</b>")
        await asyncio.sleep(600)
        await aks.delete()
        await m.delete()
        if (str(message.chat.id)).startswith("-100") and not await db.get_chat(message.chat.id):
            total=await client.get_chat_members_count(message.chat.id)
            group_link = await message.chat.export_invite_link()
            user = message.from_user.mention if message.from_user else "Dear" 
            await client.send_message(LOG_CHANNEL, script.NEW_GROUP_TXT.format(message.chat.title, message.chat.id, message.chat.username, group_link, total, user))       
            await db.add_chat(message.chat.id, message.chat.title)
        return 
    if not await db.is_user_exist(message.from_user.id):
        await db.add_user(message.from_user.id, message.from_user.first_name)
        await client.send_message(LOG_CHANNEL, script.NEW_USER_TXT.format(message.from_user.id, message.from_user.mention))
    if len(message.command) != 2:
        buttons = [[
            InlineKeyboardButton('‚áÜ ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥òs ‚áÜ', url=f'http://telegram.me/{temp.U_NAME}?startgroup=start')
        ],[
            InlineKeyboardButton('‚öô Íú∞·¥á·¥Ä·¥õ·¥ú Ä·¥ás', callback_data='features'),
            InlineKeyboardButton('üí∏ ·¥ò Ä·¥á·¥ç…™·¥ú·¥ç', callback_data='buy_premium')
        ],[
            InlineKeyboardButton('üö´ ·¥á·¥Ä Ä…¥ ·¥ç·¥è…¥·¥á è ·¥°…™·¥õ ú  ô·¥è·¥õ üö´', callback_data='earn')
        ]]   
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply_text(script.START_TXT.format(message.from_user.mention, get_status(), message.from_user.id),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        return

    if len(message.command) == 2 and message.command[1] in ["subscribe", "error", "okay", "help", "buy_premium"]:
        if message.command[1] == "buy_premium":
            btn = [[
                InlineKeyboardButton('üì∏ s·¥á…¥·¥Ö s·¥Ñ Ä·¥á·¥á…¥s ú·¥è·¥õ üì∏', url=USERNAME)
            ],[
                InlineKeyboardButton('üóë ·¥Ñ ü·¥ès·¥á üóë', callback_data='close_data')
            ]]            
            await message.reply_photo(
                photo=(QR_CODE),
                caption=script.PREMIUM_TEXT.format(message.from_user.mention),
                reply_markup=InlineKeyboardMarkup(btn)
            )
            return
        buttons = [[
            InlineKeyboardButton('‚áÜ ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥òs ‚áÜ', url=f'http://t.me/{temp.U_NAME}?startgroup=start')
        ],[
            InlineKeyboardButton('‚öô Íú∞·¥á·¥Ä·¥õ·¥ú Ä·¥ás', callback_data='features'),
            InlineKeyboardButton('üí∏ ·¥ò Ä·¥á·¥ç…™·¥ú·¥ç', callback_data='buy_premium')
        ],[
            InlineKeyboardButton('üö´ ·¥á·¥Ä Ä…¥ ·¥ç·¥è…¥·¥á è ·¥°…™·¥õ ú  ô·¥è·¥õ üö´', callback_data='earn')
        ]]
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply_text(
            text=script.START_TXT.format(message.from_user.mention, get_status(), message.from_user.id),
            reply_markup=reply_markup,
            parse_mode=enums.ParseMode.HTML
        )
        return

    data = message.command[1]
    try:
        pre, grp_id, file_id = data.split('_', 2)
    except:
        pre, grp_id, file_id = "", 0, data

    settings = await get_settings(int(data.split("_", 2)[1]))
    id = settings.get('fsub_id', AUTH_CHANNEL)
    channel = int(id)
    if settings.get('fsub_id', AUTH_CHANNEL) and not await is_subscribed(client, message.from_user.id, channel):
        invite_link = await client.create_chat_invite_link(channel)
        btn = [[
                InlineKeyboardButton("‚õîÔ∏è ·¥ä·¥è…™…¥ …¥·¥è·¥° ‚õîÔ∏è", url=invite_link.invite_link)
                ]]
        if message.command[1] != "subscribe":
            btn.append([InlineKeyboardButton("‚ôªÔ∏è ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥ ‚ôªÔ∏è", url=f"https://t.me/{temp.U_NAME}?start={message.command[1]}")])
        await client.send_message(
            chat_id=message.from_user.id,
            text=script.FSUB_TXT.format(message.from_user.mention),
            reply_markup=InlineKeyboardMarkup(btn),
            parse_mode=enums.ParseMode.HTML
        )
        return
            
    user_id = m.from_user.id
    if not await db.has_premium_access(user_id):
        grp_id = int(grp_id)
        user_verified = await db.is_user_verified(user_id)
        settings = await get_settings(grp_id)
        is_second_shortener = await db.use_second_shortener(user_id, settings.get('verify_time', TWO_VERIFY_GAP)) 
        is_third_shortener = await db.use_third_shortener(user_id, settings.get('third_verify_time', THREE_VERIFY_GAP))
        if settings.get("is_verify", IS_VERIFY) and (not user_verified or is_second_shortener or is_third_shortener):
            verify_id = ''.join(random.choices(string.ascii_uppercase + string.digits, k=7))
            await db.create_verify_id(user_id, verify_id)
            temp.CHAT[user_id] = grp_id
            verify = await get_shortlink(f"https://telegram.me/{temp.U_NAME}?start=notcopy_{user_id}_{verify_id}_{file_id}", grp_id, is_second_shortener, is_third_shortener)
            if is_third_shortener:
                rahul = settings.get('tutorial_three', TUTORIAL3)
            else:
                rahul = settings.get('tutorial_two', TUTORIAL2) if is_second_shortener else settings.get('tutorial', TUTORIAL)
            buttons = [[
                InlineKeyboardButton(text="‚úÖÔ∏è ·¥†·¥á Ä…™Íú∞ è ‚úÖÔ∏è", url=verify),
                InlineKeyboardButton(text="‚ùó  ú·¥è·¥° ·¥õ·¥è ·¥†·¥á Ä…™Íú∞ è ‚ùì", url=rahul)
            ]]
            reply_markup=InlineKeyboardMarkup(buttons)
            if await db.user_verified(user_id): 
                msg = script.THIRDT_VERIFICATION_TEXT
            else:            
                msg = script.SECOND_VERIFICATION_TEXT if is_second_shortener else script.VERIFICATION_TEXT
            d = await m.reply_text(
                text=msg.format(message.from_user.mention, get_status()),
                protect_content = True,
                reply_markup=reply_markup,
                parse_mode=enums.ParseMode.HTML
            )
            await asyncio.sleep(300) 
            await d.delete()
            await m.delete()
            return
            
    if data.startswith("allfiles"):
        _, grp_id, key = data.split("_", 2)
        files = temp.FILES_ID.get(key)
        if not files:
            await message.reply_text("<b>‚ö†Ô∏è ·¥Ä ü ü Íú∞…™ ü·¥ás …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö ‚ö†Ô∏è</b>")
            return
        settings = await get_settings(int(grp_id))
        all_files = []
        for file in files:
            settings = await get_settings(int(grp_id))
            CAPTION = settings['caption']
            f_caption = CAPTION.format(
                file_name = file.file_name,
                file_size = get_size(file.file_size),
                file_caption=file.caption
            )
            btn=[[
                InlineKeyboardButton("·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üëÄ / Íú∞·¥Äs·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö üì•", callback_data=f'stream#{file.file_id}')
            ]]
            dlt=await client.send_cached_media(
                chat_id=message.from_user.id,
                file_id=file.file_id,
                caption=f_caption,
                protect_content=settings['file_secure'],
                reply_markup=InlineKeyboardMarkup(btn)
            )
            all_files.append(dlt)
        await asyncio.sleep(600)
        for dlt_file in all_files:
            await dlt_file.delete()
        t=await client.send_message(message.from_user.id, "<b>‚ö†Ô∏è  è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥ás·¥õ·¥á·¥Ö Íú∞…™ ü·¥á …™s ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö ·¥õ·¥è ·¥Ä·¥†·¥è…™·¥Ö ·¥Ñ·¥è·¥ò è Ä…™…¢ ú·¥õ …™…¥  ô·¥è·¥õ, …™Íú∞  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥Ä…¢·¥Ä…™…¥ ·¥õ ú·¥á…¥ s·¥á·¥Ä Ä·¥Ñ ú ·¥Ä…¢·¥Ä…™…¥ ‚ò∫Ô∏è</b>")
        await asyncio.sleep(120)
        await t.delete()
        return

    type_, grp_id, file_id = data.split("_", 2)
    files_ = await get_file_details(file_id)
    if not files_:
        return await message.reply('<b>‚ö†Ô∏è Íú∞…™ ü·¥ás …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö ‚ö†Ô∏è</b>')
    files = files_[0]
    grp_id = int(grp_id)
    user_id = message.from_user.id
    settings = await get_settings(int(grp_id))
    if type_ != 'shortlink' and not settings.get("is_verify", IS_VERIFY):
        link = await get_shortlink(f"https://t.me/{temp.U_NAME}?start=shortlink_{user_id}_{file_id}", grp_id)
        mention = message.from_user.mention
        wish = get_status()
        name = files.file_name
        size = get_size(files.file_size)
        btn = [[
            InlineKeyboardButton("‚úÖ Íú∞…™ ü·¥á ‚úÖ", url=link),
            InlineKeyboardButton("‚ÅâÔ∏è  ú·¥è·¥° ·¥õ·¥è ·¥è·¥ò·¥á…¥ ‚ÅâÔ∏è", url=settings['tutorial'])
        ],[
            InlineKeyboardButton("üòÅ  ô·¥ú è Íú±·¥ú ôÍú±·¥Ñ Ä…™·¥ò·¥õ…™·¥è…¥ - ·¥Ö…™ Ä·¥á·¥Ñ·¥õ Íú∞…™ ü·¥áÍú± üòÅ", callback_data='buy_premium')
        ]]
        await message.reply(f"<b> ú è {mention} {wish},</b>\n\nüìÇ ùêçùêöùê¶ùêû ‚û†  <code>{name}</code>\n\n‚ôªÔ∏è ùêíùê¢ùê≥ùêû ‚û†  {size}\n\n<b><i> è·¥è·¥ú Ä Íú∞…™ ü·¥á …™Íú±  Ä·¥á·¥Ä·¥Ö è, ·¥ò ü·¥á·¥ÄÍú±·¥á …¢·¥á·¥õ ·¥úÍú±…™…¥…¢ ·¥õ ú…™Íú±  ü…™…¥·¥ã üòã.</i></b>", reply_markup=InlineKeyboardMarkup(btn), protect_content=True)
        return

    files_ = await get_file_details(file_id)           
    if not files_:
        pre, file_id = ((base64.urlsafe_b64decode(data + "=" * (-len(data) % 4))).decode("ascii")).split("_", 1)
        return await message.reply('<b>‚ö†Ô∏è ·¥Ä ü ü Íú∞…™ ü·¥ás …¥·¥è·¥õ Íú∞·¥è·¥ú…¥·¥Ö ‚ö†Ô∏è</b>')
    files = files_[0]
    settings = await get_settings(int(grp_id))
    CAPTION = settings['caption']
    f_caption = CAPTION.format(
        file_name = files.file_name,
        file_size = get_size(files.file_size),
        file_caption=files.caption
    )
    btn = [[
        InlineKeyboardButton("·¥°·¥Ä·¥õ·¥Ñ ú ·¥è…¥ ü…™…¥·¥á üëÄ / Íú∞·¥Äs·¥õ ·¥Ö·¥è·¥°…¥ ü·¥è·¥Ä·¥Ö üì•", callback_data=f'stream#{file_id}')
    ]]
    d=await client.send_cached_media(
        chat_id=message.from_user.id,
        file_id=file_id,
        caption=f_caption,
        protect_content=settings['file_secure'],
        reply_markup=InlineKeyboardMarkup(btn)
    )
    await asyncio.sleep(600)
    await d.delete()
    r = await message.reply_text("<b>‚ö†Ô∏è  è·¥è·¥ú Ä  Ä·¥á«´·¥ú·¥ás·¥õ·¥á·¥Ö Íú∞…™ ü·¥á …™s ·¥Ö·¥á ü·¥á·¥õ·¥á·¥Ö ·¥õ·¥è ·¥Ä·¥†·¥è…™·¥Ö ·¥Ñ·¥è·¥ò è Ä…™…¢ ú·¥õ, …™Íú∞  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥Ä…¢·¥Ä…™…¥ ·¥õ ú·¥á…¥ s·¥á·¥Ä Ä·¥Ñ ú ·¥Ä…¢·¥Ä…™…¥ ‚ò∫Ô∏è</b>")
    await asyncio.sleep(120)
    await r.delete()

@Client.on_message(filters.command('settings'))
async def settings(client, message):
    user_id = message.from_user.id if message.from_user else None
    if not user_id:
        return await message.reply("<b>üíî  è·¥è·¥ú ·¥Ä Ä·¥á ·¥Ä…¥·¥è…¥ è·¥ç·¥è·¥úÍú± ·¥Ä·¥Ö·¥ç…™…¥  è·¥è·¥ú ·¥Ñ·¥Ä…¥'·¥õ ·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö...</b>")
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<code>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò.</code>")
    grp_id = message.chat.id
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    settings = await get_settings(grp_id)
    title = message.chat.title
    if settings is not None:
            buttons = [[
                InlineKeyboardButton('·¥Ä·¥ú·¥õ·¥è Íú∞…™ ü·¥õ·¥á Ä', callback_data=f'setgs#auto_filter#{settings["auto_filter"]}#{grp_id}'),
                InlineKeyboardButton('·¥è…¥ ‚úîÔ∏è' if settings["auto_filter"] else '·¥èÍú∞Íú∞ ‚úó', callback_data=f'setgs#auto_filter#{settings["auto_filter"]}#{grp_id}')
            ],[
                InlineKeyboardButton('Íú∞…™ ü·¥á s·¥á·¥Ñ·¥ú Ä·¥á', callback_data=f'setgs#file_secure#{settings["file_secure"]}#{grp_id}'),
                InlineKeyboardButton('·¥è…¥ ‚úîÔ∏è' if settings["file_secure"] else '·¥èÍú∞Íú∞ ‚úó', callback_data=f'setgs#file_secure#{settings["file_secure"]}#{grp_id}')
            ],[
                InlineKeyboardButton('…™·¥ç·¥Ö ô', callback_data=f'setgs#imdb#{settings["imdb"]}#{grp_id}'),
                InlineKeyboardButton('·¥è…¥ ‚úîÔ∏è' if settings["imdb"] else '·¥èÍú∞Íú∞ ‚úó', callback_data=f'setgs#imdb#{settings["imdb"]}#{grp_id}')
            ],[
                InlineKeyboardButton('s·¥ò·¥á ü ü ·¥Ñ ú·¥á·¥Ñ·¥ã', callback_data=f'setgs#spell_check#{settings["spell_check"]}#{grp_id}'),
                InlineKeyboardButton('·¥è…¥ ‚úîÔ∏è' if settings["spell_check"] else '·¥èÍú∞Íú∞ ‚úó', callback_data=f'setgs#spell_check#{settings["spell_check"]}#{grp_id}')
            ],[
                InlineKeyboardButton('·¥Ä·¥ú·¥õ·¥è ·¥Ö·¥á ü·¥á·¥õ·¥á', callback_data=f'setgs#auto_delete#{settings["auto_delete"]}#{grp_id}'),
                InlineKeyboardButton(f'{get_readable_time(DELETE_TIME)}' if settings["auto_delete"] else '·¥èÍú∞Íú∞ ‚úó', callback_data=f'setgs#auto_delete#{settings["auto_delete"]}#{grp_id}')
            ],[
                InlineKeyboardButton(' Ä·¥ás·¥ú ü·¥õ ·¥ç·¥è·¥Ö·¥á', callback_data=f'setgs#link#{settings["link"]}#{str(grp_id)}'),
                InlineKeyboardButton(' ü…™…¥·¥ã' if settings["link"] else ' ô·¥ú·¥õ·¥õ·¥è…¥', callback_data=f'setgs#link#{settings["link"]}#{str(grp_id)}')
            ],[
                InlineKeyboardButton('Íú∞…™ ü·¥áÍú± ·¥ç·¥è·¥Ö·¥á', callback_data=f'setgs#is_verify#{settings.get("is_verify", IS_VERIFY)}#{grp_id}'),
                InlineKeyboardButton('·¥†·¥á Ä…™Íú∞ è' if settings.get("is_verify", IS_VERIFY) else 'Íú± ú·¥è Ä·¥õ ü…™…¥·¥ã', callback_data=f'setgs#is_verify#{settings.get("is_verify", IS_VERIFY)}#{grp_id}')
            ],[
                InlineKeyboardButton('‚òïÔ∏è ·¥Ñ ü·¥ès·¥á ‚òïÔ∏è', callback_data='close_data')
            ]]
            t=await message.reply_text(
                text=f"·¥Ñ ú·¥Ä…¥…¢·¥á  è·¥è·¥ú Ä s·¥á·¥õ·¥õ…™…¥…¢s Íú∞·¥è Ä <b>'{title}'</b> ·¥Äs  è·¥è·¥ú Ä ·¥°…™s ú ‚ú®",
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode=enums.ParseMode.HTML
            )
    else:
        await message.reply_text('<b>Íú±·¥è·¥ç·¥á·¥õ ú…™…¥…¢ ·¥°·¥á…¥·¥õ ·¥° Ä·¥è…¥…¢</b>')
        await asyncio.sleep(120)
        await t.delete() 

@Client.on_message(filters.command('template')) 
async def save_template(client, message):
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    grp_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    try:
        template = message.text.split(" ", 1)[1]
    except:
        return await message.reply_text("…™…¥·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö üòí")    
    await save_group_settings(grp_id, 'template', template)
    await message.reply_text(f"<b>s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è ·¥Ñ ú·¥Ä…¥…¢·¥á·¥Ö ·¥õ·¥á·¥ç·¥ò ü·¥Ä·¥õ·¥á Íú∞·¥è Ä {title} ·¥õ·¥è\n\n{template}</b>", disable_web_page_preview=True)
    
@Client.on_message(filters.command("send"))
async def send_msg(bot, message):
    if message.from_user.id not in ADMINS:
        await message.reply('<b>·¥è…¥ ü è ·¥õ ú·¥á  ô·¥è·¥õ ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö...</b>')
        return
    if message.reply_to_message:
        target_ids = message.text.split(" ")[1:]
        if not target_ids:
            await message.reply_text("<b>·¥ò ü·¥á·¥ÄÍú±·¥á ·¥ò Ä·¥è·¥†…™·¥Ö·¥á ·¥è…¥·¥á ·¥è Ä ·¥ç·¥è Ä·¥á ·¥úÍú±·¥á Ä …™·¥ÖÍú± ·¥ÄÍú± ·¥Ä Íú±·¥ò·¥Ä·¥Ñ·¥á...</b>")
            return
        out = "\n\n"
        success_count = 0
        try:
            users = await db.get_all_users()
            for target_id in target_ids:
                try:
                    user = await bot.get_users(target_id)
                    out += f"{user.id}\n"
                    await message.reply_to_message.copy(int(user.id))
                    success_count += 1
                except Exception as e:
                    out += f"‚ÄºÔ∏è ·¥á Ä Ä·¥è Ä …™…¥ ·¥õ ú…™Íú± …™·¥Ö - <code>{target_id}</code> <code>{str(e)}</code>\n"
            await message.reply_text(f"<b>‚úÖÔ∏è Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è ·¥ç·¥áÍú±Íú±·¥Ä…¢·¥á Íú±·¥á…¥·¥õ …™…¥ `{success_count}` …™·¥Ö\n<code>{out}</code></b>")
        except Exception as e:
            await message.reply_text(f"<b>‚ÄºÔ∏è ·¥á Ä Ä·¥è Ä - <code>{e}</code></b>")
    else:
        await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö ·¥ÄÍú± ·¥Ä  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä…¥ è ·¥ç·¥áÍú±Íú±·¥Ä…¢·¥á, Íú∞·¥è Ä ·¥á…¢ - <code>/send userid1 userid2</code></b>")

@Client.on_message(filters.command('caption'))
async def save_caption(client, message):
    grp_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    try:
        caption = message.text.split(" ", 1)[1]
    except:
        return await message.reply_text("<b><u>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s - </b>\n<code>/caption Join [Here](https://telegram.me/MovieVillaYT)\n\nFILE : {file_name}\nSize : {file_size}</code>")
    await save_group_settings(grp_id, 'caption', caption)
    await message.reply_text(f"<b>s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è ·¥Ñ ú·¥Ä…¥…¢·¥á·¥Ö ·¥Ñ·¥Ä·¥ò·¥õ…™·¥è…¥ Íú∞·¥è Ä {title} ·¥õ·¥è\n\n{caption}</b>", disable_web_page_preview=True) 
    
@Client.on_message(filters.command("tutorial"))
async def tutorial(bot, message):
    chat_type = message.chat.type
    if chat_type == enums.ChatType.PRIVATE:
        return await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò.</b>")
    elif chat_type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        grpid = message.chat.id
        title = message.chat.title
    else:
        return
    userid = message.from_user.id
    user = await bot.get_chat_member(grpid, userid)
    if user.status != enums.ChatMemberStatus.ADMINISTRATOR and user.status != enums.ChatMemberStatus.OWNER and str(userid) not in ADMINS:
        await message.reply_text("<b>·¥è…¥ ü è …¢ Ä·¥è·¥ú·¥ò ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö üòÇ</b>")
        return
    try:
        tutorial = re.findall("(?P<url>https?://[^\s]+)", message.text)[0]
    except:
        return await message.reply_text("<b><u><i>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</i></u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s - </b>\n<code>/tutorial https://youtu.be/0c-i2Lol6LU</code>")
    reply = await message.reply_text("<b>·¥ò ü·¥á·¥ÄÍú±·¥á ·¥°·¥Ä…™·¥õ...</b>")
    await save_group_settings(grpid, 'tutorial', tutorial)
    await reply.edit_text(f"<b>s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è ·¥Ñ ú·¥Ä…¥…¢·¥á·¥Ö ·¥õ·¥ú·¥õ·¥è Ä…™·¥Ä ü Íú∞·¥è Ä {title}</b>\n\n ü…™…¥·¥ã - {tutorial}", disable_web_page_preview=True)

@Client.on_message(filters.command("tutorial2"))
async def tutorial_two(bot, message):
    chat_type = message.chat.type
    if chat_type == enums.ChatType.PRIVATE:
        return await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò.</b>")
    elif chat_type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        grpid = message.chat.id
        title = message.chat.title
    else:
        return
    userid = message.from_user.id
    user = await bot.get_chat_member(grpid, userid)
    if user.status != enums.ChatMemberStatus.ADMINISTRATOR and user.status != enums.ChatMemberStatus.OWNER and str(userid) not in ADMINS:
        await message.reply_text("<b>·¥è…¥ ü è …¢ Ä·¥è·¥ú·¥ò ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö üòÇ</b>")
        return
    try:
        tutorial_two = re.findall("(?P<url>https?://[^\s]+)", message.text)[0]
    except:
        return await message.reply_text("<b><u><i>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</i></u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s - </b>\n<code>/tutorial2 https://youtu.be/GdaUbzxDTKs</code>")
    reply = await message.reply_text("<b>·¥ò ü·¥á·¥ÄÍú±·¥á ·¥°·¥Ä…™·¥õ...</b>")
    await save_group_settings(grpid, 'tutorial_two', tutorial_two)
    await reply.edit_text(f"<b>s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è ·¥Ñ ú·¥Ä…¥…¢·¥á·¥Ö ùü∏…¥·¥Ö ·¥õ·¥ú·¥õ·¥è Ä…™·¥Ä ü Íú∞·¥è Ä {title}</b>\n\n ü…™…¥·¥ã - {tutorial_two}", disable_web_page_preview=True)

@Client.on_message(filters.command("tutorial3"))
async def tutorial_three(bot, message):
    chat_type = message.chat.type
    if chat_type == enums.ChatType.PRIVATE:
        return await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò.</b>")
    elif chat_type in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        grpid = message.chat.id
        title = message.chat.title
    else:
        return
    userid = message.from_user.id
    user = await bot.get_chat_member(grpid, userid)
    if user.status != enums.ChatMemberStatus.ADMINISTRATOR and user.status != enums.ChatMemberStatus.OWNER and str(userid) not in ADMINS:
        await message.reply_text("<b>·¥è…¥ ü è …¢ Ä·¥è·¥ú·¥ò ·¥è·¥°…¥·¥á Ä ·¥Ñ·¥Ä…¥ ·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö üòÇ</b>")
        return
    try:
        tutorial_three = re.findall("(?P<url>https?://[^\s]+)", message.text)[0]
    except:
        return await message.reply_text("<b><u><i>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</i></u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s - </b>\n<code>/tutorial3 https://youtu.be/rddlpYLm0G0</code>")
    reply = await message.reply_text("<b>·¥ò ü·¥á·¥ÄÍú±·¥á ·¥°·¥Ä…™·¥õ...</b>")
    await save_group_settings(grpid, 'tutorial_three', tutorial_three)
    await reply.edit_text(f"<b>s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è ·¥Ñ ú·¥Ä…¥…¢·¥á·¥Ö ùüπ Ä·¥Ö ·¥õ·¥ú·¥õ·¥è Ä…™·¥Ä ü Íú∞·¥è Ä {title}</b>\n\n ü…™…¥·¥ã - {tutorial_three}", disable_web_page_preview=True)

@Client.on_message(filters.command('shortlink'))
async def set_shortner(c, m):
    grp_id = m.chat.id
    title = m.chat.title
    if not await is_check_admin(c, grp_id, m.from_user.id):
        return await m.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')        
    if len(m.text.split()) == 1:
        await m.reply("<b><u>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s -\n`/shortlink onepagelink.in 8c09653e5c38f84d1b76ad3197c5a023e53b494d`</b>")
        return        
    sts = await m.reply("<b>‚ôªÔ∏è ·¥Ñ ú·¥á·¥Ñ·¥ã…™…¥…¢...</b>")
    await asyncio.sleep(1.2)
    await sts.delete()
    chat_type = m.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await m.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    try:
        URL = m.command[1]
        API = m.command[2]
        resp = requests.get(f'https://{URL}/api?api={API}&url=https://telegram.me/MovieVillaYT').json()
        if resp['status'] == 'success':
            SHORT_LINK = resp['shortenedUrl']
        await save_group_settings(grp_id, 'shortner', URL)
        await save_group_settings(grp_id, 'api', API)
        await m.reply_text(f"<b>‚úÖ <u>s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è  è·¥è·¥ú Ä s ú·¥è Ä·¥õ…¥·¥á Ä …™s ·¥Ä·¥Ö·¥Ö·¥á·¥Ö</u>\n\n·¥Ö·¥á·¥ç·¥è - {SHORT_LINK}\n\ns…™·¥õ·¥á - `{URL}`\n\n·¥Ä·¥ò…™ - `{API}`</b>", quote=True)
        user_id = m.from_user.id
        user_info = f"@{m.from_user.username}" if m.from_user.username else f"{m.from_user.mention}"
        link = (await c.get_chat(m.chat.id)).invite_link
        grp_link = f"[{m.chat.title}]({link})"
        log_message = f"#New_Shortner_Set_For_1st_Verify\n\nName - {user_info}\nId - `{user_id}`\n\nDomain name - {URL}\nApi - `{API}`\nGroup link - {grp_link}"
        await c.send_message(LOG_API_CHANNEL, log_message, disable_web_page_preview=True)
    except Exception as e:
        await save_group_settings(grp_id, 'shortner', SHORTENER_WEBSITE)
        await save_group_settings(grp_id, 'api', SHORTENER_API)
        await m.reply_text(f"<b><u>üí¢ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥è·¥ú Ä·¥á·¥Ö!!</u>\n\n·¥Ä·¥ú·¥õ·¥è ·¥Ä·¥Ö·¥Ö·¥á·¥Ö  ô·¥è·¥õ ·¥è·¥°…¥·¥á Ä ·¥Ö·¥áÍú∞·¥ú ü·¥õ s ú·¥è Ä·¥õ…¥·¥á Ä\n\n…™Íú∞  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ ú·¥Ä…¥…¢·¥á ·¥õ ú·¥á…¥ ·¥ús·¥á ·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ Íú∞·¥è Ä·¥ç·¥Ä·¥õ ·¥è Ä ·¥Ä·¥Ö·¥Ö ·¥†·¥Ä ü…™·¥Ö s ú·¥è Ä·¥õ ü…™…¥·¥ã ·¥Ö·¥è·¥ç·¥Ä…™…¥ …¥·¥Ä·¥ç·¥á & ·¥Ä·¥ò…™\n\n è·¥è·¥ú ·¥Ñ·¥Ä…¥ ·¥Ä üs·¥è ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ …™…¥ ·¥è·¥ú Ä <a href=https://telegram.me/NobiDeveloperSupport>s·¥ú·¥ò·¥ò·¥è Ä·¥õ …¢ Ä·¥è·¥ú·¥ò</a> Íú∞·¥è Ä Íú±·¥è ü·¥†…™…¥…¢ ·¥õ ú…™s …™ss·¥ú·¥á...\n\nüíî ·¥á Ä Ä·¥è Ä - <code>{e}</code></b>", quote=True)

@Client.on_message(filters.command('shortlink2'))
async def set_shortner_2(c, m):
    grp_id = m.chat.id
    title = m.chat.title
    if not await is_check_admin(c, grp_id, m.from_user.id):
        return await m.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    if len(m.text.split()) == 1:
        await m.reply("<b><u>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s -\n`/shortlink2 tnshort.net 0c8ebd63bfe9f67f9970b8767498ff60316b9b03`</b>")
        return
    sts = await m.reply("<b>‚ôªÔ∏è ·¥Ñ ú·¥á·¥Ñ·¥ã…™…¥…¢...</b>")
    await asyncio.sleep(1.2)
    await sts.delete()
    chat_type = m.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await m.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    try:
        URL = m.command[1]
        API = m.command[2]
        resp = requests.get(f'https://{URL}/api?api={API}&url=https://telegram.me/NobiDeveloperr').json()
        if resp['status'] == 'success':
            SHORT_LINK = resp['shortenedUrl']
        await save_group_settings(grp_id, 'shortner_two', URL)
        await save_group_settings(grp_id, 'api_two', API)
        await m.reply_text(f"<b>‚úÖ <u> è·¥è·¥ú Ä ùü∏…¥·¥Ö s ú·¥è Ä·¥õ…¥·¥á Ä …™s ·¥Ä·¥Ö·¥Ö·¥á·¥Ö</u>\n\n·¥Ö·¥á·¥ç·¥è - {SHORT_LINK}\n\ns…™·¥õ·¥á - `{URL}`\n\n·¥Ä·¥ò…™ - `{API}`</b>", quote=True)
        user_id = m.from_user.id
        user_info = f"@{m.from_user.username}" if m.from_user.username else f"{m.from_user.mention}"
        link = (await c.get_chat(m.chat.id)).invite_link
        grp_link = f"[{m.chat.title}]({link})"
        log_message = f"#New_Shortner_Set_For_2nd_Verify\n\nName - {user_info}\nId - `{user_id}`\n\nDomain name - {URL}\nApi - `{API}`\nGroup link - {grp_link}"
        await c.send_message(LOG_API_CHANNEL, log_message, disable_web_page_preview=True)
    except Exception as e:
        await save_group_settings(grp_id, 'shortner_two', SHORTENER_WEBSITE2)
        await save_group_settings(grp_id, 'api_two', SHORTENER_API2)
        await m.reply_text(f"<b><u>üí¢ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥è·¥ú Ä·¥á·¥Ö!!</u>\n\n·¥Ä·¥ú·¥õ·¥è ·¥Ä·¥Ö·¥Ö·¥á·¥Ö  ô·¥è·¥õ ·¥è·¥°…¥·¥á Ä ·¥Ö·¥áÍú∞·¥ú ü·¥õ s ú·¥è Ä·¥õ…¥·¥á Ä\n\n…™Íú∞  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ ú·¥Ä…¥…¢·¥á ·¥õ ú·¥á…¥ ·¥ús·¥á ·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ Íú∞·¥è Ä·¥ç·¥Ä·¥õ ·¥è Ä ·¥Ä·¥Ö·¥Ö ·¥†·¥Ä ü…™·¥Ö s ú·¥è Ä·¥õ ü…™…¥·¥ã ·¥Ö·¥è·¥ç·¥Ä…™…¥ …¥·¥Ä·¥ç·¥á & ·¥Ä·¥ò…™\n\n è·¥è·¥ú ·¥Ñ·¥Ä…¥ ·¥Ä üs·¥è ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ …™…¥ ·¥è·¥ú Ä <a href=https://telegram.me/NobiDeveloperSupport>s·¥ú·¥ò·¥ò·¥è Ä·¥õ …¢ Ä·¥è·¥ú·¥ò</a> Íú∞·¥è Ä Íú±·¥è ü·¥†…™…¥…¢ ·¥õ ú…™s …™ss·¥ú·¥á...\n\nüíî ·¥á Ä Ä·¥è Ä - <code>{e}</code></b>", quote=True)

@Client.on_message(filters.command('log'))
async def set_log(client, message):
    grp_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    if len(message.text.split()) == 1:
        await message.reply("<b><u>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s -\n`/log -100xxxxxxxx`</b>")
        return
    sts = await message.reply("<b>‚ôªÔ∏è ·¥Ñ ú·¥á·¥Ñ·¥ã…™…¥…¢...</b>")
    await asyncio.sleep(1.2)
    await sts.delete()
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    try:
        log = int(message.text.split(" ", 1)[1])
    except IndexError:
        return await message.reply_text("<b><u>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s -\n`/log -100xxxxxxxx`</b>")
    except ValueError:
        return await message.reply_text('<b>·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á …™·¥Ö …™s …™…¥·¥õ·¥á…¢·¥á Ä...</b>')
    try:
        t = await client.send_message(chat_id=log, text="<b> ú·¥á è ·¥° ú·¥Ä·¥õ's ·¥ú·¥ò!!</b>")
        await asyncio.sleep(3)
        await t.delete()
    except Exception as e:
        return await message.reply_text(f'<b><u>üòê ·¥ç·¥Ä·¥ã·¥á s·¥ú Ä·¥á ·¥õ ú…™s  ô·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú·¥Ä·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü...</u>\n\nüíî ·¥á Ä Ä·¥è Ä - <code>{e}</code></b>')
    await save_group_settings(grp_id, 'log', log)
    await message.reply_text(f"<b>‚úÖ s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è s·¥á·¥õ  è·¥è·¥ú Ä  ü·¥è…¢ ·¥Ñ ú·¥Ä…¥…¥·¥á ü Íú∞·¥è Ä {title}\n\n…™·¥Ö `{log}`</b>", disable_web_page_preview=True)
    user_id = m.from_user.id
    user_info = f"@{m.from_user.username}" if m.from_user.username else f"{m.from_user.mention}"
    link = (await client.get_chat(message.chat.id)).invite_link
    grp_link = f"[{message.chat.title}]({link})"
    log_message = f"#New_Log_Channel_Set\n\nName - {user_info}\nId - `{user_id}`\n\nLog channel id - `{log}`\nGroup link - {grp_link}"
    await client.send_message(LOG_API_CHANNEL, log_message, disable_web_page_preview=True)  

@Client.on_message(filters.command('ginfo'))
async def all_settings(client, message):
    grp_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    settings = await get_settings(grp_id)
    if not settings["is_verify"]:
        text = f"""<b><i><u>·¥Ñ·¥ú Ä Ä·¥á…¥·¥õ ·¥†·¥Ä ü·¥ú·¥áÍú± Íú∞·¥è Ä {title}</u></i>

‚úÖÔ∏è s ú·¥è Ä·¥õ…¥·¥á Ä …¥·¥Ä·¥ç·¥á / ·¥Ä·¥ò…™
…¥·¥Ä·¥ç·¥á : `{settings["shortner"]}`
·¥Ä·¥ò…™ : `{settings["api"]}`

ü™Ñ ·¥õ·¥ú·¥õ·¥è Ä…™·¥Ä ü  ü…™…¥·¥ã -
{settings.get('tutorial', TUTORIAL)}

üåÄ Íú∞Íú±·¥ú ô ·¥Ñ ú·¥Ä…¥…¥·¥á ü …™·¥Ö -
`{settings.get('fsub_id', AUTH_CHANNEL)}`

üéØ …™·¥ç·¥Ö ô ·¥õ·¥á·¥ç·¥ò ü·¥Ä·¥õ·¥á -
`{settings['template']}`

üìÇ Íú∞…™ ü·¥á ·¥Ñ·¥Ä·¥ò·¥õ…™·¥è…¥ - `{settings['caption']}`</b>"""
    else:
       text = f"""<b><i><u>·¥Ñ·¥ú Ä Ä·¥á…¥·¥õ ·¥†·¥Ä ü·¥ú·¥áÍú± Íú∞·¥è Ä {title}</u></i>

‚úÖÔ∏è ùü∑Íú±·¥õ Íú± ú·¥è Ä·¥õ·¥á…¥·¥á Ä Íú∞·¥è Ä ·¥†·¥á Ä…™Íú∞ è
…¥·¥Ä·¥ç·¥á : `{settings["shortner"]}`
·¥Ä·¥ò…™ : `{settings["api"]}`

‚úÖÔ∏è ùü∏…¥·¥Ö Íú± ú·¥è Ä·¥õ·¥á…¥·¥á Ä Íú∞·¥è Ä ·¥†·¥á Ä…™Íú∞ è
…¥·¥Ä·¥ç·¥á : `{settings["shortner_two"]}`
·¥Ä·¥ò…™ : `{settings["api_two"]}`

‚úÖÔ∏è ùüπ Ä·¥Ö Íú± ú·¥è Ä·¥õ·¥á…¥·¥á Ä Íú∞·¥è Ä ·¥†·¥á Ä…™Íú∞ è
…¥·¥Ä·¥ç·¥á : `{settings["shortner_three"]}`
·¥Ä·¥ò…™ : `{settings["api_three"]}`

üß≠ ùü∏…¥·¥Ö ·¥†·¥á Ä…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥ ·¥õ…™·¥ç·¥á - `{settings['verify_time']}`

üß≠ ùüπ Ä·¥Ö ·¥†·¥á Ä…™Íú∞…™·¥Ñ·¥Ä·¥õ…™·¥è…¥ ·¥õ…™·¥ç·¥á - `{settings['third_verify_time']}`

1‚É£ ·¥õ·¥ú·¥õ·¥è Ä…™·¥Ä ü  ü…™…¥·¥ã -
{settings.get('tutorial', TUTORIAL)}

2‚É£ ·¥õ·¥ú·¥õ·¥è Ä…™·¥Ä ü  ü…™…¥·¥ã -
{settings.get('tutorial_two', TUTORIAL2)}

3‚É£ ·¥õ·¥ú·¥õ·¥è Ä…™·¥Ä ü  ü…™…¥·¥ã -
{settings.get('tutorial_three', TUTORIAL3)}

üìù  ü·¥è…¢ ·¥Ñ ú·¥Ä…¥…¥·¥á ü …™·¥Ö -
`{settings['log']}`

üåÄ Íú∞Íú±·¥ú ô ·¥Ñ ú·¥Ä…¥…¥·¥á ü …™·¥Ö -
`{settings.get('fsub_id', AUTH_CHANNEL)}`

üéØ …™·¥ç·¥Ö ô ·¥õ·¥á·¥ç·¥ò ü·¥Ä·¥õ·¥á -
`{settings['template']}`

üìÇ Íú∞…™ ü·¥á ·¥Ñ·¥Ä·¥ò·¥õ…™·¥è…¥ - `{settings['caption']}`</b>""" 
    
    btn = [[
        InlineKeyboardButton("·¥Ñ ü·¥ès·¥á", callback_data="close_data")
    ]]
    reply_markup=InlineKeyboardMarkup(btn)
    dlt=await message.reply_text(text, reply_markup=reply_markup, disable_web_page_preview=True)
    await asyncio.sleep(300)
    await dlt.delete()

@Client.on_message(filters.command('shortlink3'))
async def set_shortner_3(c, m):
    grp_id = m.chat.id
    title = m.chat.title
    if not await is_check_admin(c, grp_id, m.from_user.id):
        return await m.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    if len(m.text.split()) == 1:
        await m.reply("<b><u>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s -\n`/shortlink3 omegalinks.in 9c5a6c96077a1b499d8f953331221159383eb434`</b>")
        return
    sts = await m.reply("<b>‚ôªÔ∏è ·¥Ñ ú·¥á·¥Ñ·¥ã…™…¥…¢...</b>")
    await asyncio.sleep(1.2)
    await sts.delete()
    chat_type = m.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await m.reply_text("<b>·¥úÍú±·¥á ·¥õ ú…™Íú± ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    try:
        URL = m.command[1]
        API = m.command[2]
        resp = requests.get(f'https://{URL}/api?api={API}&url=https://youtube.com/@NobiDeveloper').json()
        if resp['status'] == 'success':
            SHORT_LINK = resp['shortenedUrl']
        await save_group_settings(grp_id, 'shortner_three', URL)
        await save_group_settings(grp_id, 'api_three', API)
        await m.reply_text(f"<b>‚úÖ <u>s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è  è·¥è·¥ú Ä ùüπ Ä·¥Ö s ú·¥è Ä·¥õ…¥·¥á Ä …™s ·¥Ä·¥Ö·¥Ö·¥á·¥Ö</u>\n\n·¥Ö·¥á·¥ç·¥è - {SHORT_LINK}\n\ns…™·¥õ·¥á - `{URL}`\n\n·¥Ä·¥ò…™ - `{API}`</b>", quote=True)
        user_id = m.from_user.id
        user_info = f"@{m.from_user.username}" if m.from_user.username else f"{m.from_user.mention}"
        link = (await c.get_chat(m.chat.id)).invite_link
        grp_link = f"[{m.chat.title}]({link})"
        log_message = f"#New_Shortner_Set_For_3rd_Verify\n\nName - {user_info}\nId - `{user_id}`\n\nDomain name - {URL}\nApi - `{API}`\nGroup link - {grp_link}"
        await c.send_message(LOG_API_CHANNEL, log_message, disable_web_page_preview=True)
    except Exception as e:
        await save_group_settings(grp_id, 'shortner_three', SHORTENER_WEBSITE3)
        await save_group_settings(grp_id, 'api_three', SHORTENER_API3)
        await m.reply_text(f"<b><u>üí¢ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥è·¥ú Ä·¥á·¥Ö!!</u>\n\n·¥Ä·¥ú·¥õ·¥è ·¥Ä·¥Ö·¥Ö·¥á·¥Ö  ô·¥è·¥õ ·¥è·¥°…¥·¥á Ä ·¥Ö·¥áÍú∞·¥ú ü·¥õ s ú·¥è Ä·¥õ…¥·¥á Ä\n\n…™Íú∞  è·¥è·¥ú ·¥°·¥Ä…¥·¥õ ·¥õ·¥è ·¥Ñ ú·¥Ä…¥…¢·¥á ·¥õ ú·¥á…¥ ·¥ús·¥á ·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ Íú∞·¥è Ä·¥ç·¥Ä·¥õ ·¥è Ä ·¥Ä·¥Ö·¥Ö ·¥†·¥Ä ü…™·¥Ö s ú·¥è Ä·¥õ ü…™…¥·¥ã ·¥Ö·¥è·¥ç·¥Ä…™…¥ …¥·¥Ä·¥ç·¥á & ·¥Ä·¥ò…™\n\n è·¥è·¥ú ·¥Ñ·¥Ä…¥ ·¥Ä üs·¥è ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ …™…¥ ·¥è·¥ú Ä <a href=https://telegram.me/NobiDeveloperSupport>s·¥ú·¥ò·¥ò·¥è Ä·¥õ …¢ Ä·¥è·¥ú·¥ò</a> Íú∞·¥è Ä Íú±·¥è ü·¥†…™…¥…¢ ·¥õ ú…™s …™ss·¥ú·¥á...\n\nüíî ·¥á Ä Ä·¥è Ä - <code>{e}</code></b>", quote=True)

@Client.on_message(filters.command('time2'))
async def set_time_2(client, message):
    userid = message.from_user.id if message.from_user else None
    if not userid:
        return await message.reply("<b> è·¥è·¥ú ·¥Ä Ä·¥á ·¥Ä…¥·¥è…¥ è·¥ç·¥è·¥úÍú± ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò...</b>")
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")       
    grp_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    try:
        time = int(message.text.split(" ", 1)[1])
    except:
        return await message.reply_text("<b><u>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s - </b>`/time2 1800`")
    await save_group_settings(grp_id, 'verify_time', time)
    await message.reply_text(f"<b>s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è s·¥á·¥õ ùü∏…¥·¥Ö ·¥†·¥á Ä…™Íú∞ è ·¥õ…™·¥ç·¥á Íú∞·¥è Ä {title}\n\n·¥õ…™·¥ç·¥á - <code>{time} sec</code></b>")

@Client.on_message(filters.command('time3'))
async def set_time_3(client, message):
    userid = message.from_user.id if message.from_user else None
    if not userid:
        return await message.reply("<b> è·¥è·¥ú ·¥Ä Ä·¥á ·¥Ä…¥·¥è…¥ è·¥ç·¥è·¥úÍú± ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò...</b>")
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")       
    grp_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    try:
        time = int(message.text.split(" ", 1)[1])
    except:
        return await message.reply_text("<b><u>…™…¥·¥†·¥Ä…™ ü·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ!!</u>\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s - </b>`/time3 3600`")
    await save_group_settings(grp_id, 'third_verify_time', time)
    await message.reply_text(f"<b>s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è s·¥á·¥õ ùüπ Ä·¥Ö ·¥†·¥á Ä…™Íú∞ è ·¥õ…™·¥ç·¥á Íú∞·¥è Ä {title}\n\n·¥õ…™·¥ç·¥á - <code>{time} sec</code></b>")

@Client.on_message(filters.command('fsub'))
async def set_fsub(client, message):
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")
    grp_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    try:
        channel_id = int(message.text.split(" ", 1)[1])
    except IndexError:
        return await message.reply_text("<b>·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á\n\n·¥ús·¥á  ü…™·¥ã·¥á ·¥õ ú…™s -\n`/fsub -100xxxxxxxx`</b>")
    except ValueError:
        return await message.reply_text('<b>·¥ç·¥Ä·¥ã·¥á Íú±·¥ú Ä·¥á ·¥õ ú·¥á …™·¥Ö …™Íú± ·¥Ä…¥ …™…¥·¥õ·¥á…¢·¥á Ä.</b>')
    try:
        chat = await client.get_chat(channel_id)
    except Exception as e:
        return await message.reply_text(f"<b><code>{channel_id}</code> …™Íú± …™…¥·¥†·¥Ä ü…™·¥Ö. ·¥ç·¥Ä·¥ã·¥á Íú±·¥ú Ä·¥á <a href=https://telegram.me/{temp.B_LINK}</a> …™Íú± ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú·¥Ä·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü\n\n<code>{e}</code></b>")
    if chat.type != enums.ChatType.CHANNEL:
        return await message.reply_text(f"ü´• <code>{channel_id}</code> ·¥õ ú…™Íú± …™Íú± …¥·¥è·¥õ ·¥Ñ ú·¥Ä…¥…¥·¥á ü, Íú±·¥á…¥·¥Ö ·¥ç·¥á ·¥è…¥ ü è ·¥Ñ ú·¥Ä…¥…¥·¥á ü …™·¥Ö …¥·¥è·¥õ …¢ Ä·¥è·¥ú·¥ò …™·¥Ö</b>")
    await save_group_settings(grp_id, 'fsub_id', channel_id)
    mention = message.from_user.mention
    await client.send_message(LOG_CHANNEL, f"#Fsub_Channel_set\n\nUser - {mention} set the force channel for {title}:\n\nFsub channel - {chat.title}\nId - `{channel_id}`")
    await message.reply_text(f"<b>Íú±·¥ú·¥Ñ·¥Ñ·¥áÍú±Íú±Íú∞·¥ú ü ü è Íú±·¥á·¥õ Íú∞·¥è Ä·¥Ñ·¥á Íú±·¥ú ôÍú±·¥Ñ Ä…™ ô·¥á ·¥Ñ ú·¥Ä…¥…¥·¥á ü Íú∞·¥è Ä {title}\n\n·¥Ñ ú·¥Ä…¥…¥·¥á ü …¥·¥Ä·¥ç·¥á - {chat.title}\n…™·¥Ö <code>{channel_id}</code></b>")

@Client.on_message(filters.command('nofsub'))
async def remove_fsub(client, message):
    chat_type = message.chat.type
    if chat_type not in [enums.ChatType.GROUP, enums.ChatType.SUPERGROUP]:
        return await message.reply_text("<b>·¥ús·¥á ·¥õ ú…™s ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ö …™…¥ …¢ Ä·¥è·¥ú·¥ò...</b>")       
    grp_id = message.chat.id
    title = message.chat.title
    if not await is_check_admin(client, grp_id, message.from_user.id):
        return await message.reply_text('<b> è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™…¥ ·¥õ ú…™Íú± …¢ Ä·¥è·¥ú·¥ò</b>')
    settings = await get_settings(grp_id)
    if settings.get('fsub_id', AUTH_CHANNEL) == AUTH_CHANNEL:
        await message.reply_text("<b> è·¥è·¥ú  ú·¥Ä·¥†·¥á…¥'·¥õ s·¥á·¥õ ·¥Ä…¥ è Íú∞s·¥ú ô ·¥Ñ ú·¥Ä…¥…¥·¥á ü  è·¥á·¥õ ü§™\n·¥õ ú·¥á…¥  ú·¥è·¥° ·¥Ñ·¥Ä…¥  è·¥è·¥ú  Ä·¥á·¥ç·¥è·¥†·¥á …™·¥õ</b>")
    else:
        await save_group_settings(grp_id, 'fsub_id', AUTH_CHANNEL)
        mention = message.from_user.mention
        await client.send_message(LOG_CHANNEL, f"#Remove_Fsub_Channel\n\nUser - {mention} he remove fsub channel from {title}")
        await message.reply_text(f"<b>‚úÖ s·¥ú·¥Ñ·¥Ñ·¥ássÍú∞·¥ú ü ü è  Ä·¥á·¥ç·¥è·¥†·¥á·¥Ö Íú∞·¥è Ä·¥Ñ·¥á Íú±·¥ú ô ·¥Ñ ú·¥Ä…¥…¥·¥á ü.</b>")

@Client.on_message(filters.command("donate"))
async def donation(bot, message):
    btn = [[
        InlineKeyboardButton(text="‚ùå   ·¥Ñ ü·¥ès·¥á   ‚ùå", callback_data="close_data")
    ]]
    yt=await message.reply_photo(photo='https://envs.sh/LR6.jpg', caption=script.DONATE_TXT, reply_markup=InlineKeyboardMarkup(btn))
    await asyncio.sleep(300)
    await yt.delete()
    await message.delete()
